以下が私がプレゼンで言いたいことです。本質的にはどのような主張をしたいのでしょうか。またプレゼンの構成例を教えてください。

# 言いたいことを列挙

フロントエンドとバックエンドの違いを議論されることが多いが、むしろ同じアプリケーションとしての共通点を理解した方が理解が深まる。

フロントエンドとバックエンドを区別するよりも前に、両方ともソフトウェアであることに注目する考え方の方が役立つ。

プラクティスは同じ。核となるロジックと周辺ロジックを切り分け、依存の向きを整理すること。

フロントエンドとバックエンドの役割は要件による。一概に言うのはおかしい。

例えば、「フロントエンドのバリデーションはUXのため」「バックエンドのバリデーションの役割はシステムを守るため」というような主張をよく見かける。これは断言できるものではなく、完全に要件によるとしか言えない。また、この捉え方をしない方がソフトウェアを正確にとらえられているとも言える。


フロントエンドの計算機アプリを例にとる。計算機アプリでは、数値や記号を入力しなければならないので、フロントエンドでバリデーションをかける必要がある。これはUXのためではない。フロントエンドのシステムを守るためにある。

※ 計算機アプリの場合、そもそもUIを工夫することで、バリデーション不要

計算結果を保存する機能が欲しくなったとする。このとき、以下のようなAPIを利用して、保存する。

- LocalStorage
- バックエンドAPI
- DB
- ストレージ

フロントエンド目線、バックエンドはただ永続化や重たい処理をするための一つの手段でしかない。

バックエンドで計算機アプリを実装することになったとする。その場合も、バリデーションはシステムを守るためにある。

計算結果を保存する機能が欲しくなったとする。フロントエンド同様、以下のようなAPIを利用して、保存する

- 別のバックエンドAPI
- DB
- ストレージ

意見として、「バックエンドはデータが正しい状態にあることを保証する必要があるが、フロントエンドはそうではない」という考え方がある。が、それは現実を正しく捉えられていない。

別にバックエンドだって、おかしいデータをDBに投げ入れる戦略だって取れるはずだ。DB側のスキーマのバリデーションに依存すれば、バックエンド側でバリエーションをかける必要はない。

核となるロジックにバリデーションロジックを置いておきたいから、バックエンドにバリデーションを持たせている。DBにバリデーションの責務を持たせていると、DB以外のソリューションに永続化を依存した瞬間にバリデーション
ができなくなる。だからバリデーションは核となるロジックに含めたほうがいい、という見方。

フロントエンドだって同様である。フロントエンドも、バックエンドにバリデーションを丸投げすることだってできる。でもフロントエンドにバリデーションを持たせる。その意義の一つが、バックエンド非依存になること。バックエンドのAPIが変わっても、バックエンドのAPIを完全に別サービスに移行しても、バックエンドじゃなくてDBやストレージサービスに移行しても、核となるロジックに置いたバリデーションロジックはそのまま動作し続けられる。

動作する環境と入出力が違うだけで、フロントエンドもバックエンドも同じアプリケーションである。そう捉える方が現実を正しく捉えられている。

そして上記のことを理解したうえで、フロントエンドとバックエンドをあえて密結合にすることを選択すべきだ。フロントエンドとバックエンドを密結合にするとお互いロックインしてしまう。しかし例えばOpen API記述などを利用してAPI周りが便利になるので、開発スピードを高めることができる。

もちろん、ロックインしてしまったら、フロントエンド目線、依存の移行が難しくなる。バックエンドAPIの変更には弱くなるし、永続化にバックエンド以外の選択肢を取ることも難しくなる。そのトレードオフを理解すべきだ。


# スライドの構成

## 主張

フロントエンドとバックエンドは本質的に同じ"ソフトウェア"と捉える


## フロントエンドとバックエンドのよくある議論

バリデーションに関して、以下のような議論が見られる

- フロントエンド側: UXのために実装する
- バックエンド側: システムを守るために実装する

この捉え方は正確ではない


---

フロントエンドとバックエンドの本質

スライド1：従来の議論と問題点

フロントエンドとバックエンドはよく区別される

例：「フロントはUXのため」「バックエンドはシステム保護のため」

しかし、この捉え方は必ずしも正確ではない

スライド2：本質は同じソフトウェアである

フロントエンドもバックエンドもソフトウェア

本質的な違いは、動作環境と入出力の差だけ

両者は共通の原則で設計できる

スライド3：共通するプラクティス

核となるロジックと周辺ロジックを切り分ける

依存関係を整理し、明確に保つ

具体的例：バリデーション、永続化の扱い

スライド4：計算機アプリの例から考える

フロントエンドにバリデーション：UXのためではなくシステム保護のため

バックエンドでもバリデーション：同じくシステム保護のため

永続化のAPI（LocalStorage, DB, ストレージ等）は両方に共通

スライド5：誤った一般論への指摘

「バックエンドはデータ整合性を保証すべき、フロントエンドは不要」という考え方

実際には、バックエンドもDBや他サービスにバリデーションを任せることも可能

本質は、バリデーションを核のロジックに含めるべきという考え方

スライド6：バリデーションを核に置く理由

永続化先を変更する際、核ロジックに含めることで安定する

フロントエンドもバックエンド非依存になり、変更や移行に強くなる

バックエンドAPI、DB、ストレージが変更されても安定する

スライド7：密結合のメリット

フロントエンドとバックエンドを意図的に密結合させる選択

例えばOpenAPI記述を使うことで、開発効率が劇的に向上する

スピードを優先するときに有効な戦略

スライド8：密結合のトレードオフ

一度密結合すると移行・変更が困難になる

バックエンド変更、永続化先変更などの柔軟性が減少

このトレードオフを明確に理解し、戦略的に利用することが重要

スライド9：まとめ

フロントエンドとバックエンドは同じソフトウェアとして捉えるべき

核となるロジックを中心に設計を統一する

密結合化の利点とトレードオフを理解し、意識的に選択しよう



---

全体の流れ

フロントエンドとバックエンドを区別するよくある主張
- バリデーション

本当に区別することがより良い設計につながるのだろうか？いや、それは違う。

要件によって決まる。スタート地点は、フロントエンドとバックエンドは両方ともソフトウェアであること。

そもそもフロントエンドとバックエンドって何が違うんだっけ？

→ 入出力だけ

入出力が違うだけのただのソフトウェアとして捉える

特定の入出力に沿っていれば、フロントエンドがバックエンドを使ってもいいし、バックエンドがフロントエンドを使ってもいいし、ユーザーがフロントエンドを使ってもいいし、ユーザーがバックエンドを使ってもいい

じゃあバックエンド非依存なフロントエンドも考えられるよね

ノートアプリとかまさにそんな感じじゃん。(つぶやき投稿アプリで140文字のバリデーションの話の方がいいかも)

永続化は、直接ストレージサービス読んでもいいし。バリデーションの話だって、ここでバリデーションかけなきゃ正しいフォーマットで保存されないじゃん。


入出力以外、フロントエンドとバックエンドは同じソフトウェア
→ 依存を整理するプラクティスは共通する
→ 核となるロジックと周辺のロジックを分ける
→ 外部依存は周辺ロジックに置く

ただのソフトウェア。だから誰が使ってもいい
フロントエンドをバックエンドが使ってもいい
バックエンドを人間が使ってもいい

バックエンド非依存のフロントエンドもある


まとめ

バックエンドとフロントエンドは入出力が違うだけの同じソフトウェアである
依存を管理する設計論は役にたつ
別々に捉える設計論はpointless 持たせる役割は要件による

フロントエンドはバックエンド非依存にすることができる
そうすることで、外部システムへのロックインを避けることができ、移行が簡単になる
そう設計する方がより保守性の高いソフトウェアだと言える。

開発のスピードを速めるために、フロントエンドをバックエンドに完全に依存させる選択もできる。
一方で、これはフロントエンドをバックエンドに完全依存させるため、トレードオフとなる。
ここにトレードオフがあると自覚して開発すべき。


入出力以外同じことを示す
→ 依存の管理方法のプラクティスは役にたつ
→ それ以外のプラクティスもフロントエンドに応用可能
→ バックエンド非依存の保守性の高いフロントエンドを設計可能
  → バックエンドと密結合のフロントエンドも可能だが、トレードオフがあることを自覚すべき
  → 別々に扱う設計論は、設計の幅を狭めている

