# Order

You are going to help developers to work on the presentation.

The contents will be in the "Contents" section.


# TODO

- Create all the empty pages
- Create tentative cover page
- Choose good theme of Slidiv
- Fill each page


# Contents

辛いよね

→ 辛い実例

→ なぜ辛いのか

→ 辛くなくするにはどうすればいいか

→  ざっくりとした解決策の考え方

→ 具体的な解決策

Appendixに漫画とか、Tipsとかを詰め込む

## 辛い

フロントエンドは敬遠されがち。

「トレンドの移り変わりが早すぎる😵‍💫」

「また新しいフレームワークが出た。キャッチアップしないと置いていかれる😢」

「またライブラリで脆弱性が見つかった。バージョンアップしてテストしないと😮‍💨」

「Majorバージョンあげたら信じられない数のBreaking Changesが入ってる😡」

「コードを変更したら、知らない間に別のところが壊れていた😳」

「と思ったらテストが全く書かれてないじゃん😱」

バックエンドは単体テストを書きやすいし、クリーンアーキテクチャやDDDなどの方法論も普及してきている。

管理しやすいイメージがある。

## なぜ辛いのか

「依存の向きが整理されていないから」

- UIに全く関係ない箇所(例: ビジネスロジック、APIコール、バリデーション)でUIフレームワークに依存してしまう
- 核となるロジックが状態管理ライブラリに依存してしまう

### 実例: AngularJSのマイグレーション

フロントエンドフレームワーク。EOLした。

基本的には全てをAngularJSに依存するような書き方をする。

フルスクラッチでの書き直しが必要になる。

何年もかかる。

### 実例: Recoilのアーカイブ

状態管理ライブラリ。

コードベース全体で依存しがち。多くの箇所で書き直しが必要になる。

### その書き直しは本当に必要だったのか？

- UIに関係ない箇所もUIフレームワークに依存してしまっていたからでは？
- 状態管理ライブラリってそもそも必要？

→ 依存を整理しましょう！

## 依存を整理しましょう

核となるロジックと、周辺のロジックを明確に分けよう。

核となるロジックは、周辺のロジックに依存しない。

周辺のロジックが核となるロジックに合わせる。

例えば、バリデーションロジックは、UIに依存しない。入力フォームの位置が変わったからって、バリデーション結果が変わらない。

バリデーションロジックに合わせて、UIは変化する。バリデーション結果がエラーだったら、エラーメッセージが表示されるべき。

## フロントエンドもバックエンドも同じ考え方ができる

### クリーンアーキテクチャとの類似性

これはバックエンドで普及しているクリーンアーキテクチャと同じ

永続性レイヤーにRDBMSを使っても、NoSQLを使っても、ファイルシステムを使っても、手元のメモ帳を使ってもいい。

核となるロジックには、永続性レイヤーがどう実装されているかは気にしない。

### UIは付け替え可能なレイヤー

核となるロジックさえ分離できていれば、その核となるロジックを別のUIに付け替えることが可能。

つまりAngularJSがEOLしたら、同じ核となるロジックを再利用しつつReactと使うことが可能。

同じ核となるロジックをCLIに移植することも可能。携帯でも、VRでも、音声対話システムでも、スマートグラスでも、ロボットでもいい。どんなUIにも使いまわせる。

## 核となるロジックを、TypeScriptだけで実装していこう

### シンプルなカウンターアプリの例

カウンターの実装。

ちなみにVue.jsのReactivity Fundamentalsでも使用されている例。

https://vuejs.org/guide/essentials/reactivity-fundamentals.html

要件

- カウントの初期状態は0
- カウントアップボタンを押すと、カウントを1増やす

Vue.jsの機能をフルに使った実装をすることもできる。

でも、これって核となるロジックが切り分けられてない。つまり…

- 依存すべきではないものに依存している
    - 核となるロジックを移植できない
        - 依存するライブラリのEOL、バージョンアップグレードの際、核となるロジックも影響する
    - テストが難しい
        - テストのセットアップ処理や、モックが大変。テストが書かれない原因になる
    
    <aside>
    💡
    
    もっといい書き方できる気もする。推敲対象
    
    </aside>
    

じゃあどうする？核となるロジックをTypeScriptのみで記述してみよう。

```tsx
class Counter {
  public count: number = 0
  
  increment(): void {
    this.count++
  }
}
```

これは単体テスト可能。

別UIに移行しても動かすことができる。

実際にこれをもとにUIをレンダリングさせると、こういうコンポーネントになる。

### カウンターアプリをさらに複雑にする: バリデーション

Vue.jsでバリデーションをするなら、VeeValidateを利用する選択がある。

じゃあ、VeeValidateでカウンターアプリを実装してみよう

要件

- カウントの最大値は100
- 最大値を超えてカウントアップできない
- カウントアップできないことが一目で分かるようにする

こんな感じになる

しかし、これでは核となるはずのバリデーションロジックが、VeeValidateというライブラリに依存していて、VeeValidateはVue.jsというUIライブラリに依存している。

つまり、バリデーションロジックがUIライブラリに依存している。

すると…

- 核となるロジックを移植できない
- テストが難しい

<aside>
💡

推敲対象

</aside>

じゃあTypeScriptだけで実装するアプローチを再度試してみよう。色々実装方法はあるけど…

```tsx
class Counter {
  public count: number = 0
  public readonly countMax: number = 100
  
  canIncrement(): boolean {
    if (this.count + 1 > this.countMax) {
      return false
    }

    return true
  }

  increment(): void {
    if (this.canIncrement()) {
      this.count++
    }
  }
}
```

このように書ける。以下の特徴を持つ

- 再利用可能
- 単体テスト可能

Vue.js上で表現するとこうなる

### カウンターアプリをさらに複雑にする: Dependency Injection

要件が追加された。

- アプリを再起動しても、同じカウントを表示したい (カウントを永続化したい)

Vue.jsで書くとこんな感じになる

※ .vueファイル内で、初期化時にFetch APIを呼ぶ & incrementのたびにFetch APIを呼ぶ 

が、先ほど同様

- 核となるロジックを移植できない
- テストが難しい

じゃあTypeScriptだけで実装するアプローチを再度試してみよう。ここではDIを使おう。

```tsx
// バリデーションロジック・エラーハンドリングは省略
class Counter {
  public count: number = 0
  
  constructor(
    private readonly counterService: ICounterService
  ) {}

  increment(): Promise<void> {
    this.count++
    await this.counterService.update(this.count)
  }

  async load(): Promise<void> {
    const this.count = await this.counterService.get()
  }
}
```

こうすることで、DIのメリットを享受できる。

- Counterはカウントに集中する
- 具体的な永続化の方法は別のサービス等に切り出す

先ほどと同様に

- 再利用可能
- 単体テスト可能

Vue.js上でこれを使うとこうなる

※ 分かりやすさのために手動DIで書こう

### さらにDIを活用しよう

手動のDIは大変。DIライブラリを使用すると楽になる。

DIライブラリを使用すると、Vue.js内では以下のように書ける

※ InverisfyJSを使用

そのためにはinterfaceを定義したり、DIの設定をする必要がある

### 単純なプログラミングの問題となる

核となるロジックをTypeScriptのみを使ってで切り出すことで、単純なプログラミングの問題となる。

単純なTypeScriptに落とし込めるため、必要に応じて関数型のアイディアを取り入れたり、イベント駆動の考え方を取り入れたり、スタートマシーンの考え方を取り入れたりなど、必要なデザインパターンを持ち込める。

また、依存の向きを意識しやすくなる。

- 核となるロジックはUIについて知らない
- 核となるロジックは永続化レイヤの実装について知らない

この考え方はクリーンアーキテクチャと同じ。

核となるロジックを切り出せた結果として

- 移植できる形になった
- 単体テスト可能になった
- UIライブラリ非依存な部分ができた
- 状態管理ライブラリは不要になった

それだけでなく、必要なデザインパターンを実装しやすい。そしてそれらは移植・単体テスト可能である

## Model-View-ViewModel (MVVM) パターン

### 紹介

MVVMで実現できることは、先ほど述べたことと同じである。

ViewがUIのロジックを担当する

ViewModelが核となるロジックを持つ

ViewModelはViewに依存しない

### さきほどの例をViewModelに書き直す

核となるロジックにViewModelという名前をつけただけ。

ViewModelはViewと直接やりとりする。

ViewModelが肥大化しないようにロジックを切り分ける。ViewModelを分割したり、DIで詳細を切り分けたりする。

```tsx
class CounterViewModel implements ICounterViewModel {
  public count: number = 0
  
  constructor(
    private readonly counterService: ICounterService
  ) {}

  async increment(): Promise<void> {
    this.count++
    await this.counterService.update(this.count)
  }

  async load(): Promise<void> {
    const this.count = await this.counterService.get()
  }
}
```

## ViewModelのUI非依存性

### WebUIだけがUIじゃない

これまでWebUIに着目して話してきた。ViewModelを作ったら、同じものをVueでもReactでもAngularでも使える。

しかしWebUI以外のUIもある。CLI、音声対話システム、ロボット、人間。

ユーザーとの入出力があって、ECMAScriptが動く環境であれば、先ほどのViewModelは再利用可能である。

### デモ

WebUIと音声対話システムで同じViewModelを使いまわせると示す。

## まとめ

依存の向きを意識しよう

具体的な方法としては……

フロントエンドをViewとViewModelに分割し、ViewModelはViewに依存しないようにする

ViewModelは核となるロジックである。依存を排除して、TypeScriptで記述する。

このようにすることで、UIフレームワークによる影響を最小化し、状態管理ライブラリは不要になる。

開発者は純粋なプログラミングによって、要件を満たしていくことに集中できる。

そしてその成果は、UIフレームワークなどのトレンドからの影響を受けない。異なるUIに移植することもできる。

ちょっと休憩

関連して言いたいことを少し発展編に切り出したので、もう少しお付き合いください。

## 発展編

### どこまでがViewで、どこまでがViewModelか

(Appendixに移動でいい)

実際に実装しようとして、何をViewに書いて、何をViewModelに書いていいか悩むことがあります。

例えばi18nの機能はどちらが持つべきでしょうか。

このときに役立つ考え方は、

View は How (どのように見せるか) に責任を持つ

ViewModel は What (何を見せるか) に責任を持つ

という考え方です

こう考えることで、見せ方の部分だけViewに任せ、残りは全部ViewModel側に寄せることができます。

ViewModelの世界はTypeScriptによる純粋なプログラミングが可能な世界です。UI非依存で、単体テスト可能。UIフレームワークの知識ゼロで開発できます

i18nの場合、キーはViewModelが持ち、翻訳はViewが行うという切り分けがすっきりします。

### フロントエンドもバックエンドも両方アプリケーション

ぱっと見の違いがあるだけで、フロントエンドもバックエンドも両方アプリケーションです。

なぜ違うと感じるのか。それは入出力が違って見えるからです。

フロントエンドはユーザーから入力を受け取り、UIを返します。

バックエンドはユーザーから入力を受け取り、JSONやXMLなどの文字列を返します。

フロントエンドは人間だけから利用されるものではなく、Playwrightなどの自動化ツールからも利用されます。つまりバックエンドがフロントエンドを操作することが可能ということです。

バックエンドはフロントエンドだけから叩かれるものではなく、バックエンド同士で叩き合ったり、人間が手動でリクエストを送れるものです。

### アプリケーションとして共通すること

ただ入出力が違うというだけで、両方ともアプリケーションです。

つまり、入力に対してバリデーションをし、処理を走らせ、出力を返す。ものによっては副作用を起こしたり、エラーハンドリングをしたりする。

という点でフロントエンドとバックエンドは変わりません。

### アプリケーションとして共通のガイドライン

「核となるロジックは周辺のロジックに依存すべきではない」というのはアプリケーション共通の考え方です。

例えば、入出力まわりのロジックと、核となるロジックを切り分けて、核となるロジックは入出力まわりのロジックに依存しないようにすべきです。

フロントエンドにおいては「核となるロジックはUIフレームワークに依存してはならない」と考え

バックエンドにおいては「核となるロジックはバックエンドフレームワークに依存してはならない」となります。

## Appendix

よりViewModelの書き方のアイディアなどをまとめていく

# 関連資料

https://learn.microsoft.com/ja-jp/dotnet/architecture/maui/mvvm

https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html