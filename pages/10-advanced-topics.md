---
layout: section
transition: slide-left
---

# フロントエンドも
# バックエンドも
# 同じソフトウェア

---

## よくあるフロントエンドとバックエンドの誤解

バリデーションの役割について:

- フロントエンド側: UXのためにバリデーションを実装する
- バックエンド側: システムを守るためにバリデーションを実装する

これは要件次第であり、必ずしも正確ではない。

---

## 例: 計算機アプリ

計算機アプリにおいて、フロントエンドのバリデーションは正常なシステム動作のために必要である。

UXのためではない。

| 領域 | バリデーションの目的 | 具体例 |
| --- | --- | --- |
| フロントエンド | ❌ UXのためではない。<br>✅ システム保護のため | 数字や記号以外の入力を防ぐ |
| バックエンド<br>(履歴保存など) | ✅ システム保護のため | 誤ったデータ形式を防ぐ |

---
layout: section
---

# 共通点と相違点

---

## フロントエンドとバックエンドの共通点

<div class="pt-8" />

- 入力を受け付ける
- 入力にバリデーションをかける
- 処理を実行する
- 必要に応じて外部システムを利用する
  - 永続化のため
  - 重たい処理のため
  - etc.
- 必要に応じてエラーハンドリングをする
- 出力を返す

**ソフトウェアとしてほとんど同じ**

---

## バックエンドとフロントエンドの主な違い: 入出力

<div class="pt-4" />

- フロントエンドの入力: ユーザーの行動
- フロントエンドの出力: 新しいUI

<div class="pt-4" />

- バックエンドの入力: HTTPリクエスト
- バックエンドの出力: HTTPレスポンス

<div class="pt-4" />

見かけが大きく違うので区別されている。

フロントエンドとバックエンドを全く別のものと考えるより、**入出力が違うだけのソフトウェアとして捉える方が正確**。

<!-- 人間に最適化されたUIがフロントエンドで、ソフトウェアに最適化されたUIがバックエンドと捉えることもできる -->

---

## 補足: 他の違い

<div class="pt-8" />

- 通信環境
- 実行環境
- セキュリティ
- etc.

実際、これらによって要件や外部設計は影響を受ける。

詳細設計以降については、先ほどのスライドで説明した通りになる。

---

## ソフトウェアのプラクティスは両方に適用可能

依存を整理するプラクティスは両方に応用可能:

- 核となるロジックと周辺のロジックを分離する
- 外部依存は周辺ロジックに配置する

---
layout: section
---

# バックエンド非依存な
# フロントエンド

---

## バックエンド非依存なフロントエンド

フロントエンドをバックエンド非依存にすることで、外部システムに左右されにくい保守性の高いフロントエンドを開発できる。

---

## 例: メモアプリの永続化

メモを投稿できるフロントエンドアプリを考える。メモは永続化する必要がある。

永続化には以下の選択肢がある:

- 自社のバックエンドAPIを用意する
- DBに直接保存する
- 他社のバックエンドAPIを利用する (Google Drive API等)
- LocalStorage等を使って端末に保存する

**どれか一つにロックインすると、乗り換えられなくなる**

---

## 例: メモアプリのバリデーション

フロントエンドのバリデーションを、以下のような場所で行える:

- バックエンドに丸投げする
- DBに丸投げする
- フロントエンドの周辺のロジックで行う
- フロントエンドの核となるロジックで行う

**フロントエンドの核となるロジックでバリデーションを行うことで**...

- バックエンドAPI経由でも...
- DBに直接保存する場合でも...
- 他社のバックエンドAPI経由でも...
- LocalStorage等の端末上に保存する場合でも...

**常に整合性のとれたデータが保存できる**。

---
layout: section
---

# "あえて"密結合にする

---

## フロントエンドとバックエンドをあえて密結合にする

フロントエンドとバックエンドをあえて密結合にして、OpenAPI関連のツールを利用することなどにより、開発の高速化が可能である。

例えば、フロントエンドの型の自動生成によって、フロントエンドで型を書く手間を削減できる。

一方で、フロントエンドが特定のAPIにロックインされてしまうため、保守性は下がる。バックエンド側で変更があったとき、フロントエンド全体に影響が出る可能性がある。

「みんなやっているからバックエンドとフロントエンドを密結合にする」のではなく、**トレードオフがあると認識しつつ、開発の高速化のために密結合の選択をしたい**。

---
layout: section
---

# 区別しすぎると
# 思考の幅を狭めるかも

---

### 「フロントエンドはUIをやるもの」

→ No。

フロントエンドでアプリケーションを完結させることができる。

<div class="pt-4" />

### 「バックエンドは整合性のとれたデータを保存するもの」

→ No。

DBにバリデーションを任せるという考え方もできる。

バックエンドを介さず、フロントエンドから直接ストレージサービス等に保存することもできる。

---

### 「Web開発では、フロントエンドと、バックエンドを1つずつ用意する」

→ No。場合による。

場合によっては...:

- フロントエンドだけで完結させることができる
- バックエンドだけで完結させることができる
- バックエンドが別のバックエンドを呼ぶこともある
- バックエンドが別のフロントエンドを操作することもある (ブラウザ自動化ツールを利用)

フロントエンドとバックエンドの数を決めうつのではなく、要件に対して必要なソフトウェアを用意すると考える方が現実に即している。

---

## まとめ

**フロントエンドもバックエンドも同じソフトウェアである**。

なので...

- フロントエンドとバックエンドには共通の設計原則を適用できる。
  - 例: 「核となるロジック」と「周辺のロジック」を分け、外部依存にロックインしない設計
- フロントエンドとバックエンドを密結合させる際は、トレードオフがあることを認識したい。
- この2つの役割を区別して断言する意見は慎重に聞きたい。
  - 例: フロントエンドのバリデーションの役割はUXの改善のためだ
  - 例: フロントエンドではバックエンドの方法論を使えない・使うべきでない

