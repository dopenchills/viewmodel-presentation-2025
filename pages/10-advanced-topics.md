---
layout: section
transition: slide-left
---

# 依存性の方向と
# クリーンアーキテクチャ

---

## MVVMとクリーンアーキテクチャの関連性

<div class="pt-4" />

<div class="grid grid-cols-2 gap-4">

<div>
<h4>MVVM</h4>
<Transform :scale="1">
  <img src="./.images/mvvm-vertical.png" />
</Transform>
</div>

<div>
<h4>クリーンアーキテクチャ</h4>
<Transform :scale="0.9">
  <img src="./.images/clean-architecture.png" />
</Transform>
</div>

</div>

<div class="pt-4" />

両者の共通点：**依存は内側に向かう**

---

## 依存の方向の一貫性

<div class="pt-4" />

### MVVMの場合
- ViewはViewModelに依存する
- ViewModelはModelに依存する
- 逆方向には依存しない

<div class="pt-4" />

### クリーンアーキテクチャの場合
- 外側のレイヤーは内側のレイヤーに依存する
- 内側のレイヤーは外側のレイヤーに依存しない

<div class="pt-4" />

**共通原則：核となるロジックは周辺のロジックに依存しない**

---
layout: section
---

# フロントエンドも
# バックエンドも
# 同じソフトウェア

---

## フロントエンドとバックエンドの共通点

<div class="pt-8" />

- 入力を受け付ける
- 入力にバリデーションをかける
- 処理を実行する
- 必要に応じて外部システムを利用する
  - 永続化のため
  - 重たい処理のため
  - etc.
- 必要に応じてエラーハンドリングをする
- 出力を返す

**ソフトウェアとしてほとんど同じ**

---

## バックエンドとフロントエンドの主な違い: 入出力

<div class="pt-4" />

- フロントエンドの入力: ユーザーの行動
- フロントエンドの出力: 新しいUI

<div class="pt-4" />

- バックエンドの入力: HTTPリクエスト
- バックエンドの出力: HTTPレスポンス

<div class="pt-4" />

見かけが大きく違うので区別されている。

フロントエンドとバックエンドを全く別のものと考えるより、**入出力が違うだけのソフトウェアとして捉える方が正確**。

---
layout: two-cols-header
---

## バックエンドとフロントエンドの入出力と依存性管理

::left::

<Transform :scale="0.75">
<img src="./.images/input-output-frontend-backend.png" />
</Transform>

::right::

フロントエンドもバックエンドも、依存性管理の原則は同じ：

- 入出力の詳細（UI/API）は外側のレイヤー
- 核となるロジックは内側のレイヤー
- 依存の方向は内側に向かう

<div class="pt-4" />

ViewModelとクリーンアーキテクチャで共通する考え方。

---

## よくある誤解：フロントエンドとバックエンドのバリデーション

<div class="pt-4" />

- フロントエンド側: UXのためにバリデーションを実装する
- バックエンド側: システムを守るためにバリデーションを実装する

<div class="pt-4" />

これは必ずしも正確ではない。

**両方とも「正しく動作するための境界防御」という目的を持つ**

---

## 例: 計算機アプリ

計算機アプリにおいて、フロントエンドのバリデーションは正常なシステム動作のために必要。

UXのためではなく、システム防御のため。

| 領域 | バリデーションの目的 | 具体例 |
| --- | --- | --- |
| フロントエンド | ❌ UXのためではない。<br>✅ システム保護のため | 数字や記号以外の入力を防ぐ |
| バックエンド<br>(履歴保存など) | ✅ システム保護のため | 誤ったデータ形式を防ぐ |

---
layout: section
---

# アーキテクチャ選択の
# トレードオフ

---

## フロントエンドとバックエンドを疎結合にする選択

<div class="pt-4" />

一般的なWeb開発において、フロントエンドとバックエンドは強く結びついてしまいがち。

しかし、フロントエンドをバックエンド非依存にすることで**保守性の高いフロントエンド**を開発できる。

フロントエンドのコードの一部だけを変更することで、別のバックエンドAPIに乗り換えるということも可能になる。

---

## 例: メモアプリの永続化

メモを作成・管理できるフロントエンドアプリを考える。メモは永続化する必要がある。

永続化には以下の選択肢がある:

- 自社のバックエンドAPIを用意する
- DBに直接保存する
- 他社のバックエンドAPIを利用する (Google Drive API等)
- LocalStorage等を使って端末に保存する

**どれか一つにロックインすると、乗り換えられなくなる**

永続化のインターフェースを定義することで、バックエンド非依存にできる。

---

## 逆にあえて密結合にする選択

<div class="pt-4" />

フロントエンドとバックエンドをあえて密結合にして、OpenAPI関連のツールを利用することで、**開発の高速化**が可能。

<div class="pt-4" />

**トレードオフ**:
- ✅ 開発速度が向上する
- ❌ 保守性が低下する（特定APIへのロックイン）

<div class="pt-4" />

「みんなやっているから」ではなく、**トレードオフを理解した上で選択すべき**。

---

## まとめ: 依存の整理の普遍性

<div class="pt-4" />

1. MVVMとクリーンアーキテクチャは同じ基本原則に基づいている
   - **依存は内側に向かう**
   - **核となるロジックは周辺のロジックに依存しない**

2. フロントエンドとバックエンドは入出力が異なるだけの同じソフトウェア
   - 同じ設計原則が適用できる

3. 疎結合か密結合かの選択はトレードオフを伴う
   - 開発速度 vs 保守性
