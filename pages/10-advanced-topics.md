---
layout: section
transition: slide-left
---

# フロントエンドも
# バックエンドも
# 同じソフトウェア

---

## よくあるフロントエンドとバックエンドの誤解

<div class="pt-4" />

- フロントエンド側: UXのためにバリデーションを実装する
- バックエンド側: システムを守るためにバリデーションを実装する

これは要件次第であり、必ずしも正確ではない。

---

## 例: 計算機アプリ

計算機アプリにおいて、フロントエンドのバリデーションは正常なシステム動作のために必要である。

UXのためではない。

| 領域 | バリデーションの目的 | 具体例 |
| --- | --- | --- |
| フロントエンド | ❌ UXのためではない。<br>✅ システム保護のため | 数字や記号以外の入力を防ぐ |
| バックエンド<br>(履歴保存など) | ✅ システム保護のため | 誤ったデータ形式を防ぐ |

---
layout: section
---

# 共通点と相違点

---

## フロントエンドとバックエンドの共通点

<div class="pt-8" />

- 入力を受け付ける
- 入力にバリデーションをかける
- 処理を実行する
- 必要に応じて外部システムを利用する
  - 永続化のため
  - 重たい処理のため
  - etc.
- 必要に応じてエラーハンドリングをする
- 出力を返す

**ソフトウェアとしてほとんど同じ**

---

## バックエンドとフロントエンドの主な違い: 入出力

<div class="pt-4" />

- フロントエンドの入力: ユーザーの行動
- フロントエンドの出力: 新しいUI

<div class="pt-4" />

- バックエンドの入力: HTTPリクエスト
- バックエンドの出力: HTTPレスポンス

<div class="pt-4" />

見かけが大きく違うので区別されている。

フロントエンドとバックエンドを全く別のものと考えるより、**入出力が違うだけのソフトウェアとして捉える方が正確**。

<!-- 人間に最適化されたUIがフロントエンドで、ソフトウェアに最適化されたUIがバックエンドと捉えることもできる -->

---

## 依存を整理するプラクティスは両方に適用可能

<div class="pt-4" />

- 核となるロジックと周辺のロジックを分離する
- 外部依存は周辺ロジックに配置する

また、これを守ることで、核となるロジックには別の各種プラクティスを導入可能。フロントエンドかバックエンドかは関係ない。


---

## 補足: フロントエンドとバックエンドの他の違い

<div class="pt-4" />

- 通信環境
- 実行環境
- セキュリティ
- etc.

適切に抽象化すれば、「周辺のロジック」で吸収できることが多い。

例えばフロントエンドでは通信環境が悪いことが多く、キャッシュが必要なこともある。そのような要件は外部システムとのやりとりにまつわる話なので、「周辺ロジック」での実装になる。

核となるロジックを切り出せていれば、そこには影響しない。

---
layout: section
---

# バックエンド非依存な
# フロントエンド

---

## バックエンド非依存なフロントエンド

フロントエンドをバックエンド非依存にすることで、外部システムに影響を受けにくい保守性の高いフロントエンドを開発できる。

---

## 例: メモアプリの永続化

メモを作成・管理できるフロントエンドアプリを考える。メモは永続化する必要がある。

永続化には以下の選択肢がある:

- 自社のバックエンドAPIを用意する
- DBに直接保存する
- 他社のバックエンドAPIを利用する (Google Drive API等)
- LocalStorage等を使って端末に保存する

**どれか一つにロックインすると、乗り換えられなくなる**

例えば永続化のロジックをDIすることで、バックエンド非依存になる。

---

## 例: メモアプリのバリデーション

フロントエンドのバリデーションを、以下のような場所で行える:

- バックエンドに丸投げする
- DBに丸投げする
- フロントエンドの周辺のロジックで行う
- フロントエンドの核となるロジックで行う

**フロントエンドの核となるロジックでバリデーションを行うことで**...

- バックエンドAPI経由でも...
- DBに直接保存する場合でも...
- 他社のバックエンドAPI経由でも...
- LocalStorage等の端末上に保存する場合でも...

**常に整合性のとれたデータが保存できる**。

---
layout: section
---

# "あえて"密結合にする

---

## フロントエンドとバックエンドをあえて密結合にする

フロントエンドとバックエンドをあえて密結合にして、OpenAPI関連のツールを利用することなどにより、開発の高速化が可能である。

例えば、フロントエンドの型の自動生成によって、フロントエンドで型を書く手間を削減できる。

一方で、フロントエンドが特定のAPIにロックインされてしまうため、保守性は下がる。バックエンド側で変更があったとき、フロントエンド全体に影響が出る可能性がある。

「みんなやっているからバックエンドとフロントエンドを密結合にする」のではなく、**トレードオフがあると認識しつつ、開発の高速化のために密結合の選択をしたい**。

---
layout: section
---

# 区別しすぎると
# 思考の幅を狭めるかも

---

### 「フロントエンドはUIをやるもの」

→ No。

例えばフロントエンドでアプリケーションを完結させることができる。

<div class="pt-4" />

### 「バックエンドは整合性を保証してデータを保存するもの」

→ No。

例えばDBにバリデーションを任せるという考え方もできる。

バックエンドを介さず、フロントエンドから直接ストレージサービス等に保存することもできる。

---

### 「Web開発では、フロントエンドと、バックエンドを1つずつ用意する」

→ No。場合による。

場合によっては...:

- フロントエンドだけで完結させることができる
- バックエンドだけで完結させることができる
- バックエンドが別のバックエンドを呼ぶこともある
- バックエンドが別のフロントエンドを操作することもある (ブラウザ自動化ツールを利用)

フロントエンドとバックエンドに決まりきった役割があると考えるのではなく、要件に対して必要なソフトウェアを用意すると考える方が効果的。

---

## まとめ

**フロントエンドもバックエンドも同じソフトウェアである**。

なので...

- フロントエンドとバックエンドには共通の設計原則を適用できる。
  - 例: 「核となるロジック」と「周辺のロジック」を分け、外部依存にロックインしない設計
- フロントエンドとバックエンドは疎結合にできる。
  - フロントエンドとバックエンドを密結合させる際は、トレードオフがあることを認識したい。
- フロントエンドとバックエンドを区別して断言する意見は慎重に聞きたい。
  - 例: フロントエンドのバリデーションの役割はUXの改善のためだ
  - 例: フロントエンドではバックエンドの方法論を使えない・使うべきでない
